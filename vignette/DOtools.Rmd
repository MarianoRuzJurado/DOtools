---
title: "Introduction"
author:
  - name: Mariano Ruz Jurado
    affiliation:
    - Goethe University
output: 
  BiocStyle::html_document:
    self_contained: true
    toc: true
    toc_float: true
    toc_depth: 3
    code_folding: show
package: "`r pkg_ver('DOtools')`"
vignette: >
  %\VignetteIndexEntry{Introduction}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r chunk_setup, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```

```{r vignette_setup, echo=FALSE, message=FALSE, warning = FALSE}
# Track time spent on making the vignette.
start_time <- Sys.time()

# Bib setup.
library(RefManageR)

# Write bibliography information
bib <- c(
    DOtools = citation("DOtools")[1],
    scDbl = citation("scDblFinder")[2],
)
```

# Installation
`r Biocpkg("DOtools")` is an R package distributed as part of the Bioconductor
project. To install the package, start R and enter:

```{r bioconductor_install, eval=FALSE}
install.packages("BiocManager") # WORK iN PROGRESS
BiocManager::install("DOtools")
```

Alternatively, you can instead install the latest development version from [GitHub](https://github.com/) with:

```{r github_install, eval=FALSE}
install.packages("devtools")
devtools::install_github("MarianoRuzJurado/DOtools")
```

# Usage
`r Biocpkg("DOtools")` contains different functions
for processing and visualizing gene expression in scRNA/snRNA experiments:

In this vignette we showcase how to use the functions with public available data.

## Libraries

`r Biocpkg("DOtools")` can be imported as:

```{r load_library, message=FALSE}
library(DOtools)
```

## Quality Control
`r Biocpkg("DOtools")` The `r DO.Import()` function provides a streamlined pipeline for performing quality control on single-cell or single-nucleus RNA sequencing (sc/snRNA-seq) data. It takes as input a list of .h5 files generated by e.g. CellRanger or STARsolo, along with sample names and metadata.

During preprocessing, low-quality genes and cells are filtered out based on specified thresholds. Genes expressed in fewer than five cells are removed. Cells are filtered according to mitochondrial gene content, number of detected genes, total UMI counts, and potential doublets. The function supports doublet detection using `r Biocpkg("scDblFinder")` `r Citep(bib[["scDblFinder"]])`. Thresholds for mitochondrial content (e.g., 5% for scRNA-seq and 3% for snRNA-seq), gene counts, and UMI counts can be defined to tailor the filtering.

After filtering, samples are merged into one Seurat object, followed by log-normalisation, scaling, and the identification of highly variable genes. To help assess the effect of quality control, violin plots showing distributions of key metrics before and after filtering are automatically generated and saved alongside the input files. A summary of removed genes and cells is also recorded. 

To show how the quality control works, we are going to use a public dataset from 10X from human blood of healthy and donors with a malignant tumor:

```{r read_example_data}
DOtools:::.example_10x()

paths = c("/tmp/dootools_datasets/healthy/outs/",
         "/tmp/dootools_datasets/disease/outs/")

DO.Import(pathways = paths,
          ids = c("sample1", "sample2"),
          TenX = T)

```



Here we can see that some genes seem to be more expressed in one group of 
samples than in the other and vice-versa. Ideally, we would like to capture 
these differences in gene programs into interpretable biological entities. 
In this example we will do it by summarizing gene expression into transcription 
factor activities.

The toy data also contains a simple net consisting of 3 transcription factors 
(Ts) with specific regulation to target genes (either positive or negative).
This network can be visualized like a graph. Green edges are positive regulation
(activation), red edges are negative regulation (inactivation):

<img src="https://github.com/saezlab/decoupleR/blob/master/inst/figures/net_plot.png?raw=1" align="center" width="600">

According to this network, the first population of samples should show high 
activity for T1 and T3, while the second one only for T2.

## Methods
`r Biocpkg("decoupleR")` contains several methods. To check how many are 
available, run:
```{r usage-show_methods, message=TRUE}
decoupleR::show_methods()
```
Each method models biological activities in a different manner, sometimes 
returning more than one estimate or providing significance of the estimation. 
To know what each method returns, please check their documentation like this
`?run_mlm`.

To have a unified framework, methods have these shared arguments:

* `mat` : input matrix of molecular readouts.
* `network` : input prior knowledge information relating molecular features to 
biological entities.
* `.source`,`.target` and `.mor` : column names where to extract the information
from `network`. 
    * `.source` refers to the biological entities.
    * `.target` refers to the molecular features.
    * `.mor` refers to the "strength" of the interaction (if available, else 1s 
    will be used). Only available for methods that can model interaction weights. 
* `minsize` : Minimum of target features per biological entity (5 by default). 
If less, sources are removed. This filtering prevents obtaining noisy activities
from biological entities with very few matching target features in `matrix`. For
this example data-set we will have to keep it to 0 though. 

## Running methods

### Individual methods

As an example, letâ€™s first run the Gene Set Enrichment Analysis method (`gsea`), 
one of the most well-known statistics:
```{r usage-fgsea, message=TRUE}
res_gsea <- decoupleR::run_fgsea(mat = mat, 
                                 network = network, 
                                 .source = 'source', 
                                 .target = 'target', 
                                 nproc = 1, 
                                 minsize = 0)

res_gsea
```

Methods return a result data-frame containing:

* `statistic`: name of the statistic. Depending on the method, there can be more than one per method.
* `source`: name of the biological entity.
* `condition`: sample name.
* `score`: inferred biological activity.
* `p_value`: if available, significance of the inferred activity.

In the case of `gsea`, it returns a simple estimate of activities (`fgsea`), 
a normalized estimate (`norm_fgsea`) and p-values after doing permutations.

Other methods can return different things, for example Univariate Linear Model 
(`ulm`):
```{r usage-ulm, message=TRUE}
res_ulm <- decoupleR::run_ulm(mat = mat, 
                              network = network, 
                              .source = 'source', 
                              .target = 'target', 
                              .mor = 'mor', 
                              minsize = 0)

res_ulm
```

In this case, `ulm` returns just an estimate (`ulm`) and its associated p-values. 
Each method can return different statistics, we recommend to check their 
documentation to know more about them.

Let us plot the obtained results, first for `gsea`:
```{r res_gsea, message=TRUE}
# Transform to matrix
mat_gsea <- res_gsea %>%
            dplyr::filter(statistic == 'fgsea') %>%
            decoupleR::pivot_wider_profile(id_cols = source, 
                                           names_from = condition, 
                                           values_from = score) %>%
            as.matrix()

# Color scale
colors <- rev(RColorBrewer::brewer.pal(n = 11, name = "RdBu"))
colors.use <- grDevices::colorRampPalette(colors = colors)(100)

# Heatmap
pheatmap::pheatmap(mat = mat_gsea,
                   color = colors.use,
                   border_color = "white",
                   cluster_rows = FALSE,
                   cluster_cols = FALSE,
                   cellwidth = 20,
                   cellheight = 20,
                   treeheight_row = 0,
                   treeheight_col = 0)
```

We can observe that for transcription factors T1 and T2, the obtained activities
correctly distinguish the two sample populations. T3, on the other hand, should 
be down for the second population of samples since it is a repressor. 
This mislabeling of activities happens because `gsea` cannot model weights when 
inferring biological activities. 

When weights are available in the prior knowledge, we definitely recommend using 
any of the methods that take them into account to get better estimates, 
one example is `ulm`:

```{r res_ulm, message=TRUE}
# Transform to matrix
mat_ulm <- res_ulm %>%
           dplyr::filter(statistic=='ulm') %>%
           decoupleR::pivot_wider_profile(id_cols = source, 
                                          names_from = condition, 
                                          values_from = score) %>%
           as.matrix()

# Color scale
colors <- rev(RColorBrewer::brewer.pal(n = 11, name = "RdBu"))
colors.use <- grDevices::colorRampPalette(colors = colors)(100)

# Heatmap
pheatmap::pheatmap(mat = mat_ulm,
                   color = colors.use,
                   border_color = "white",
                   cluster_rows = FALSE,
                   cluster_cols = FALSE,
                   cellwidth = 20,
                   cellheight = 20,
                   treeheight_row = 0,
                   treeheight_col = 0)
```

Since `ulm` models weights when estimating biological activities, it correctly
assigns T3 as inactive in the second population of samples.

### Multiple methods

`r Biocpkg("decoupleR")` also allows to run multiple methods at the same time. 
Moreover, it computes a consensus score based on the obtained activities across 
methods, called `consensus`.

By default, `deocuple` runs only the top performer methods in our benchmark (`mlm`,
`ulm` and `wsum`), and estimates a consensus score across them. Specific 
arguments to specific methods can be passed using the variable `args`. For more 
information check `?decouple`.
```{r usage-decouple, message=TRUE}
res_decouple <- decoupleR::decouple(mat, 
                                    network, 
                                    .source ='source', 
                                    .target ='target',
                                    minsize = 0)

res_decouple
```

Let us see the result for the consensus score in the previous `decouple` run:
```{r res_decouple, message=TRUE}
# Transform to matrix
mat_consensus <- res_decouple %>%
                 dplyr::filter(statistic == 'consensus') %>%
                 decoupleR::pivot_wider_profile(id_cols = source, 
                                                names_from = condition, 
                                                values_from = score) %>%
                 as.matrix()
# Color scale
colors <- rev(RColorBrewer::brewer.pal(n = 11, name = "RdBu"))
colors.use <- grDevices::colorRampPalette(colors = colors)(100)

# Heatmap
pheatmap::pheatmap(mat = mat_consensus,
                   color = colors.use,
                   border_color = "white",
                   cluster_rows = FALSE,
                   cluster_cols = FALSE,
                   cellwidth = 20,
                   cellheight = 20,
                   treeheight_row = 0,
                   treeheight_col = 0)
```

We can observe that the consensus score correctly predicts that T1 and T3 should
be active in the first population of samples while T2 in the second one.


# Session information

```{r session_info, echo=FALSE}
options(width = 120)
sessioninfo::session_info()
```

# Bibliography

```{r vignetteBiblio, results = "asis", echo = FALSE, warning = FALSE, message = FALSE}
## Print bibliography
PrintBibliography(bib, .opts = list(hyperlink = "to.doc", style = "html"))
```

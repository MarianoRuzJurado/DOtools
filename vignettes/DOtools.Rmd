---
title: "Quality control of sc/snRNA-seq"
author:
  - name: Mariano Ruz Jurado
    affiliation:
    - Goethe University
output: 
  BiocStyle::html_document:
    self_contained: true
    toc: true
    toc_float: true
    toc_depth: 3
    code_folding: show
package: "`r pkg_ver('DOtools')`"
vignette: >
  %\VignetteIndexEntry{Quality control of sc/snRNA-seq}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r chunk_setup, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```

```{r vignette_setup, echo=FALSE, message=FALSE, warning = FALSE}
# Track time spent on making the vignette.
start_time <- Sys.time()
pkg <- function(x) {
  paste0("[*", x, "*](https://cran.r-project.org/package=", x, ")")
}
pypkg <- function(x) {
  paste0("[*", x, "*](https://pypi.org/project/", x, "/)")
}
```

# Installation
`r Biocpkg("DOtools")` is an R package distributed as part of the Bioconductor
project. To install the package, start R and enter:

```{r bioconductor_install, eval=FALSE}
install.packages("BiocManager") # WORK iN PROGRESS
BiocManager::install("DOtools")
```

Alternatively, you can instead install the latest development version from [*GitHub*](https://github.com/) with:

```{r github_install, eval=FALSE}
install.packages("devtools")
devtools::install_github("MarianoRuzJurado/DOtools")
```

# Usage
`r Biocpkg("DOtools")` contains different functions
for processing and visualizing gene expression in scRNA/snRNA experiments:

In this vignette we showcase how to use the functions with public available data.

## Libraries

`r Biocpkg("DOtools")` can be imported as:

```{r load_library, message=FALSE}
library(DOtools)

#Additional packages
library(Seurat)
library(plyr)
library(dplyr)
library(tibble)
library(enrichR)
library(kableExtra)

#Python installation set up
DO.PyEnv()
reticulate::use_python("~/.venv/DOtools/bin/python")
```

## Quality control
`r Biocpkg("DOtools")` The `DO.Import()` function provides a streamlined pipeline for performing quality control on single-cell or single-nucleus RNA sequencing (sc/snRNA-seq) data. It takes as input a list of .h5 files generated by e.g. CellRanger or STARsolo, along with sample names and metadata.

During preprocessing, low-quality genes and cells are filtered out based on specified thresholds. Genes expressed in fewer than five cells are removed. Cells are filtered according to mitochondrial gene content, number of detected genes, total UMI counts, and potential doublets. The function supports doublet detection using `r Biocpkg("scDblFinder")`. Thresholds for mitochondrial content (e.g., 5% for scRNA-seq and 3% for snRNA-seq), gene counts, and UMI counts can be defined to tailor the filtering.

After filtering, samples are merged into one `r pkg("Seurat")` or `r pkg("SingleCellExperiment")` object, followed by log-normalisation, scaling, and the identification of highly variable genes. To help assess the effect of quality control, violin plots showing distributions of key metrics before and after filtering are automatically generated and saved alongside the input files. A summary of removed genes and cells is also recorded. 

To show how the quality control works, we are going to use a public dataset from 10X from human blood of healthy and donors with a malignant tumor:

```{r read_example_data, warning = FALSE, eval=FALSE}
base <- DOtools:::.example_10x()

paths = c(file.path(base, "healthy/outs/filtered_feature_bc_matrix.h5"),
         file.path(base, "disease/outs/filtered_feature_bc_matrix.h5"))

SCE_obj <- DO.Import(pathways = paths,
                     ids = c("healthy-1", "disease-1"),
                     DeleteDoublets = TRUE,
                     cut_mt = .05,
                     min_counts = 500,
                     min_genes = 300,
                     high_quantile = .95,
                     Seurat=FALSE) # Set to TRUE for Seurat object
```
We can now check the quality before introducing filterings:
```{r prefilterplots, out.width="100%", fig.align="center", fig.width=8, fig.height=6}
prefilterplots <- system.file("figures", "prefilterplots-1.png", package = "DOtools")
pQC1 <- magick::image_read(prefilterplots)
plot(pQC1)
```
<br>
And after:
```{r postfilterplots, out.width="100%", fig.align="center", fig.width=8, fig.height=6}
postfilterplots <- system.file("figures", "postfilterplots-1.png", package = "DOtools")
pQC2 <- magick::image_read(postfilterplots)
plot(pQC2)
```
We observed that most cells were removed due to increased mitochondrial content. Depending on the experimental design, the mitochondrial content threshold can be adjusted to retain a higher number of cells, if minimizing cell loss is of relevance.

<br>
The DOtools package provides a slim object of this data set. Please feel free, to use the one created from DO.Import for prettier results or this slim downed version. We can observe how similar the samples are through running a correlation analysis.
```{r heatmap, fig.width=6, fig.height=6}
#Making sure we have a save folder
base <- tempfile("my_tempdir_")
dir.create(base)
  
SCE_obj <- readRDS(system.file("extdata", "sce_data.rds", package = "DOtools"))
DO.Correlation(SCE_obj)
```



## Data integration

After quality control the prefered integration method can be chosen within Seurat's `IntegrateLayers` function. Additionally, we implemented a new wrapper function for the scVI integration from the [scvi-tools](https://pypi.org/project/scvi-tools/) package. After the integration completes, we run the Leiden algorithm to find clusters and generate UMAP embeddings.

```{r CCA Integration, warning = FALSE}
### ADDITIONAL STEPS FOR SCE OBJECTS, THESE STEPS WILL BE PERFORMED AUTOMATICALLY FOR SEURAT OBJECTS IN DO.IMPORT
### SKIP IF YOU USE SEURAT OBJECT FROM DO.IMPORT() 
Seu_obj <- as.Seurat(SCE_obj)
Seu_obj[["RNA"]] <- split(Seu_obj[["RNA"]], f = Seu_obj$orig.ident)
Seu_obj <- FindVariableFeatures(Seu_obj)
Seu_obj <- ScaleData(object = Seu_obj)
Seu_obj <- RunPCA(Seu_obj, verbose = FALSE, reduction.name = "PCA")
Seu_obj <- JoinLayers(Seu_obj)
Seu_obj[["RNA"]] <- split(Seu_obj[["RNA"]], f = Seu_obj$orig.ident)
#####

#Integration through Seurat
Seu_obj <- IntegrateLayers(object = Seu_obj,
                           method = CCAIntegration,
                           orig.reduction = "PCA",
                           new.reduction = "INTEGRATED.CCA",
                           verbose = TRUE)

#After Integration we join the layers 
Seu_obj <- JoinLayers(Seu_obj)

#(Optional) convert back to SCE object if you prefer that data class
SCE_obj <- as.SingleCellExperiment(Seu_obj)

```

```{r scVI Integration, warning=FALSE, eval=FALSE}
#(Optional) Integration with scVI-Model
Seu_obj <- DO.scVI(sce_object = Seu_obj,
                   batch_key ="orig.ident",
                   layer_counts = "counts",
                   layer_logcounts = "logcounts")
```


After the integration finished, both corrected expression matrices can be found saved in the Seurat object and can be used for cluster calculations and UMAP projections. In this case, we will continue with Seuratv5 CCA Integration method.

```{r Clustering and UMAP, warning = FALSE}
Seu_obj <- FindNeighbors(object = Seu_obj, reduction = "INTEGRATED.CCA", dims = 1:50) #change dims accordingly
Seu_obj <- FindClusters(Seu_obj, resolution = 0.3, algorithm = 4, random.seed = 1234)
Seu_obj <- RunUMAP(object = Seu_obj, reduction = "INTEGRATED.CCA", reduction.name = "UMAP", dims = 1:50)

DO.UMAP(Seu_obj, group.by = "seurat_clusters")
DO.UMAP(Seu_obj, group.by = "condition", legend.position = "right", label = FALSE)

```


## Semi-automatic annotation with Celltypist

Next up, we implemented a wrapper around the semi-automatic annotation tool `r pypkg("celltypist")`. It will annotate the defined clusters based on the `Adult_COVID19_PBMC.pkl` model.

```{r annotation, warning = FALSE}
Seu_obj <- DO.CellTypist(Seu_obj,
                         modelName = "Healthy_COVID19_PBMC.pkl", 
                         runCelltypistUpdate=TRUE,
                         over_clustering = "seurat_clusters")
DO.UMAP(Seu_obj, group.by = "autoAnnot", legend.position = "right")

```

The semi-automatic annotation is a good estimate of the cell types in your object. But you should always manually validate the findings of the model. You can manually define a set of marker genes for the cell population or check the most preeminent genes per cluster by using Seurat's `FindAllMarkers` function.

```{r Manual annotation, fig.width=12, fig.height=7}
#pick top 5 per cluster
annotation_Markers <- FindAllMarkers(object = Seu_obj,
                                     assay = "RNA",
                                     group.by = "autoAnnot",
                                     min.pct = 0.25,
                                     logfc.threshold = 0.25)

annotation_Markers <- annotation_Markers %>%
  arrange(desc(avg_log2FC)) %>%              
  distinct(gene, .keep_all = TRUE) %>%       
  group_by(cluster) %>%
  slice_head(n = 5)   

p1 <- DO.Dotplot(sce_object = Seu_obj,
                 Feature = annotation_Markers,
                 group.by.x = "seurat_clusters",
                 plot.margin = c(1,1,1,1),
                 annotation_x = TRUE,
                 point_stroke = 0.1,
                 annotation_x_rev = TRUE,
                 textSize = 14,
                 hjust = 0.5,
                 vjust = 0,
                 textRot = 0,
                 segWidth = 0.3,
                 lwd = 3)

#manual set of markers
annotation_Markers <-  data.frame(cluster = c("ImmuneCells",
                                            rep("B_cells", 3),
                                            rep("T_cells",3),
                                            rep("NK", 2),
                                            rep("Myeloid",3),
                                            rep("pDC",3)),
                                genes = c("PTPRC", "CD79A", "BANK1", "MS4A1", "CD3E", "CD4", "IL7R", "NKG7", 
                                          "KLRD1","CD68", "CD14","ITGAM", "LILRA4", "CLEC4C", "LRRC26"))

p2 <- DO.Dotplot(sce_object = Seu_obj,
                 Feature = annotation_Markers,
                 group.by.x = "seurat_clusters",
                 plot.margin = c(1,1,1,1),
                 annotation_x = TRUE,
                 point_stroke = 0.1,
                 annotation_x_rev = TRUE,
                 textSize = 14,
                 hjust = 0.5,
                 vjust = 0,
                 textRot = 0,
                 segWidth = 0.3,
                 lwd = 3)

```

The manual markers for the immune cells show an agreement for the annotation therefore we can continue with it after some minor adjustments

```{r renaming}
Seu_obj$annotation <- plyr::revalue(Seu_obj$seurat_clusters, c(`1` = "T_cells",
                                                               `2` = "T_cells",
                                                               `3` = "NK",
                                                               `4` = "B_cells",
                                                               `5` = "Monocytes",
                                                               `6` = "NK",
                                                               `7` = "T_cells",
                                                               `8` = "pDC"))

DO.UMAP(Seu_obj, group.by = "annotation", legend.position = "right")

```

## Cell composition

After the identification of the celltype populations, we can also evaluate if there are significant changes in these populations in the healthy and diseased condition using a wrapper function around the python tool `r pypkg("scanpro")`.

```{r cell populations, warning=FALSE}
DO.CellComposition(Seu_obj,
                   assay_normalized = "RNA",
                   cluster_column = "annotation",
                   sample_column = "orig.ident",
                   condition_column = "condition",
                   transform_method = "arcsin",
                   n_reps = 3)
```


## Reclustering of cell populations

Subpopulations can be tricky to find, therefore it is always a good practice to perform a reclustering of a given cell populations, if we are interested in a specific set of cells in a population. Here for example in the T cells. We will identify the subpopulations and then markers defining them.

```{r Recluster, warning=FALSE}
Seu_obj <- DO.FullRecluster(Seu_obj, over_clustering = "annotation")
DO.UMAP(Seu_obj, group.by = "annotation_recluster")
T_cells <- DO.Subset(Seu_obj,
                     ident = "annotation_recluster",
                     ident_name = grep("T_cells", unique(Seu_obj$annotation_recluster), value = TRUE))

T_markers <- FindAllMarkers(T_cells, group.by = "annotation_recluster")

T_cells <- DO.CellTypist(T_cells,
                         modelName = "Healthy_COVID19_PBMC.pkl",
                         runCelltypistUpdate=FALSE,
                         over_clustering = "annotation_recluster",
                         SeuV5 = FALSE)
T_cells$annotation <- plyr::revalue(T_cells$annotation_recluster, c(`T_cells_1` = "CD4_T_cells",
                                                                    `T_cells_2` = "CD4_T_cells",
                                                                    `T_cells_3` = "CD4_T_cells",
                                                                    `T_cells_4` = "CD8_T_cells"))

```

Now that we identified the marker genes describing the different T cell populations. We can re-annotate them based on their expression profile and a new prediciton from Celltypist. After this we, can easily transfer the labels in the subset to the original object.

```{r re-annotate}
Seu_obj <- DO.TransferLabel(Seu_obj,
                            Subset_obj = T_cells,
                            annotation_column = "annotation",
                            subset_annotation = "annotation")

DO.UMAP(Seu_obj, group.by = "annotation", legend.position = "right")
```

## Gene ontology analysis

To explore which biological processes are enriched in a specific cell type across conditions, we can perform gene ontology analysis. We'll start by identifying differentially expressed genes, focusing here on T cells. For differential gene expression analysis, we introduced a new function, which combines DGE analysis using a single cell approach, e.g. the popular Wilcoxon test and a pseudobulk testing using DESeq2. We can then observe the results in a combined dataframe.


```{r GO analysis, warning=FALSE}
# this data set contains only one sample per condition we introduce replicates for showing the pseudo bulk approach
set.seed(123)
Seu_obj$orig.ident2 <- sample(rep(c("A", "B", "C", "D", "E", "F"), length.out = ncol(Seu_obj)))
CD4T_cells <- DO.Subset(Seu_obj, ident = "annotation", ident_name = "CD4_T_cells")

DGE_result <- DO.MultiDGE(CD4T_cells,
                          sample_col = "orig.ident2",
                          method_sc = "wilcox",
                          ident_ctrl = "healthy")

head(DGE_result,10) %>%
  kable(format = "html", table.attr = "style='width:100%;'") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

```

After inspecting the DGE analysis, we continue with `DO.enrichR` function, which uses the enrichR API to run gene set enrichment. It separates the DE genes into up- and down-regulated sets and runs the analysis for each group independently

```{r GO analysis2, warning=FALSE}
result_GO <- DO.enrichR(df_DGE = DGE_result,
                        gene_column = "gene",
                        pval_column = "p_val_adj_SC_wilcox",
                        log2fc_column = "avg_log2FC_SC_wilcox",
                        pval_cutoff = 0.05,
                        log2fc_cutoff = 0.25,
                        path = NULL,
                        filename = "",
                        species = "Human",
                        go_catgs = "GO_Biological_Process_2023")

head(result_GO,5) %>%
  kable(format = "html", table.attr = "style='width:100%;'") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```

The top significant results can then be visualized in a bar plot.

```{r GO visualisation, fig.width=10, fig.height=8}
result_GO_sig <- result_GO[result_GO$Adjusted.P.value < 0.05, ] 
result_GO_sig$celltype <- "CD4T_cells"

DO.SplitBarGSEA(df_GSEA = result_GO_sig,
                term_col = "Term",
                col_split = "Combined.Score",
                cond_col = "State",
                pos_cond = "enriched",
                showP = FALSE,
                path = paste0(base, "/"))
GSEA_plot <- list.files(path = base, pattern = "SplitBar.*\\.svg$", full.names = TRUE, recursive = TRUE)
plot(magick::image_read_svg(GSEA_plot))
```


# Session information

```{r session_info, echo=FALSE}
options(width = 120)
sessioninfo::session_info()
```

---
title: "Introduction"
author:
  - name: Mariano Ruz Jurado
    affiliation:
    - Goethe University
output: 
  BiocStyle::html_document:
    self_contained: true
    toc: true
    toc_float: true
    toc_depth: 3
    code_folding: show
package: "`r pkg_ver('DOtools')`"
vignette: >
  %\VignetteIndexEntry{Introduction}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r chunk_setup, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```

```{r vignette_setup, echo=FALSE, message=FALSE, warning = FALSE}
# Track time spent on making the vignette.
start_time <- Sys.time()

# Bib setup.
library(RefManageR)

# Write bibliography information
bib <- c(
    DOtools = citation("DOtools")[1],
    scDbl = citation("scDblFinder")[2],
    Seurat = citation("Seurat")[3]
)
```

# Installation
`r Biocpkg("DOtools")` is an R package distributed as part of the Bioconductor
project. To install the package, start R and enter:

```{r bioconductor_install, eval=FALSE}
install.packages("BiocManager") # WORK iN PROGRESS
BiocManager::install("DOtools")
```

Alternatively, you can instead install the latest development version from [GitHub](https://github.com/) with:

```{r github_install, eval=FALSE}
install.packages("devtools")
devtools::install_github("MarianoRuzJurado/DOtools")
```

# Usage
`r Biocpkg("DOtools")` contains different functions
for processing and visualizing gene expression in scRNA/snRNA experiments:

In this vignette we showcase how to use the functions with public available data.

## Libraries

`r Biocpkg("DOtools")` can be imported as:

```{r load_library, message=FALSE}
library(DOtools)

#Additional packages
library(Seurat)
library(plyr)
library(dplyr)
library(tibble)
library(enrichR)

#Python installation set up
DO.PyEnv()
reticulate::use_python("~/.venv/DOtools/bin/python")
```

## Quality control
`r Biocpkg("DOtools")` The `r DO.Import()` function provides a streamlined pipeline for performing quality control on single-cell or single-nucleus RNA sequencing (sc/snRNA-seq) data. It takes as input a list of .h5 files generated by e.g. CellRanger or STARsolo, along with sample names and metadata.

During preprocessing, low-quality genes and cells are filtered out based on specified thresholds. Genes expressed in fewer than five cells are removed. Cells are filtered according to mitochondrial gene content, number of detected genes, total UMI counts, and potential doublets. The function supports doublet detection using `r Biocpkg("scDblFinder")` `r Citep(bib[["scDblFinder"]])`. Thresholds for mitochondrial content (e.g., 5% for scRNA-seq and 3% for snRNA-seq), gene counts, and UMI counts can be defined to tailor the filtering.

After filtering, samples are merged into one `r Biocpkg("Seurat")` `r Citep(bib[["Seurat"]])` object, followed by log-normalisation, scaling, and the identification of highly variable genes. To help assess the effect of quality control, violin plots showing distributions of key metrics before and after filtering are automatically generated and saved alongside the input files. A summary of removed genes and cells is also recorded. 

To show how the quality control works, we are going to use a public dataset from 10X from human blood of healthy and donors with a malignant tumor:

```{r read_example_data}
DOtools:::.example_10x()

paths = c("/tmp/dotools_datasets/healthy/outs/filtered_feature_bc_matrix.h5",
         "/tmp/dotools_datasets/disease/outs/filtered_feature_bc_matrix.h5")

Seu_obj <- DO.Import(pathways = paths,
                     ids = c("healthy-1", "disease-1"),
                     TenX = T,
                     DeleteDoublets = T,
                     cut_mt = .05,
                     min_counts = 500,
                     min_genes = 300,
                     high_quantile = .95)

```



Quality control can then be checked in a vln plot and the numbers of gene and cells removed per step can be observed in a table:

<img src="QC" align="center" width="600">
<img src="QC" align="center" width="600">
<img src="QCTABLE" align="center" width="600">

We observed that most cells were removed due to increased mitochondrial content. Depending on the experimental design, the mitochondrial content threshold can be adjusted to retain a higher number of cells, if minimizing cell loss is of relevance.

## Data integration

After quality control the prefered integration method can be chosen within Seurat's `r IntegrateLayers` function. Additionally, we implemented a new wrapper function for the scVI Integration from the scvi-tools package. After the integration completes, we run the Leiden algorithm to find clusters and generate UMAP embeddings.

```{r Integration}
#Integration through Seurat
Seu_obj <- IntegrateLayers(object = Seu_obj,
                           method = CCAIntegration,
                           orig.reduction = "pca",
                           new.reduction = "integrated.cca",
                           verbose = T)

#After Integration we join the layers 
Seu_obj <- JoinLayers(Seu_obj)

#Integration with scVI
Seu_obj <- DO.scVI(Seu_object = Seu_obj,
                   batch_key ="orig.ident",
                   layer_counts = "counts",
                   layer_logcounts = "logcounts")

```

After the integration finished, both corrected expression matrices can be found saved in the Seurat object and can be used for cluster calculations and UMAP projections. In this case, we will continue with Seuratv5 CCA Integration method.

```{r Clustering and UMAP}
Seu_obj <- FindNeighbors(object = Seu_obj, reduction = "integrated.cca", dims = 1:50) #change dims accrodingly
Seu_obj <- FindClusters(Seu_obj, resolution = 0.3, algorithm=4, random.seed = 1234)
Seu_obj <- RunUMAP(object = Seu_obj, reduction = "integrated.cca", dims = 1:50)

DO.UMAP(Seu_obj, group.by = "seurat_clusters")
DO.UMAP(Seu_obj, group.by = "condition", legend.position = "right", label = F)

```


## Semi-automatic annotation with Celltypist

Next up, we implemented a wrapper around the semi-automatic annotation tool `r CellTypist`. It will annotate the defined clusters based on the `r Adult_COVID19_PBMC.pkl` model.

```{r annotation}
Seu_obj <- DO.CellTypist(Seu_obj,
                         modelName = "Healthy_COVID19_PBMC.pkl", 
                         runCelltypistUpdate=T,
                         over_clustering = "seurat_clusters")

DO.UMAP(Seu_obj, group.by = "autoAnnot", legend.position = "right")

```

The semi-automatic annotation is a good estimate of the cell types in your object. But you should always manually validate the findings of the model. You can manually define a set of marker genes for the cell population or check the most preeminent genes per cluster by using Seurat's `r FindAllMarkers` function.

```{r Manual annotation}
#pick top 5 per cluster
annotation_Markers <- FindAllMarkers(object = Seu_obj,
                                     assay = "RNA",
                                     group.by = "autoAnnot",
                                     min.pct = 0.25,
                                     logfc.threshold = 0.25)

annotation_Markers <- annotation_Markers %>%
  arrange(desc(avg_log2FC)) %>%              
  distinct(gene, .keep_all = TRUE) %>%       
  group_by(cluster) %>%
  slice_head(n = 5)   

DO.Dotplot(Seu_object = Seu_obj,
           Feature = annotation_Markers,
           group.by.x = "seurat_clusters",
           plot.margin = c(1,1,1,1),
           annotation_x = T,
           point_stroke = 0.1,
           annotation_x_rev = T,
           textSize = 14,
           hjust = 0.5,
           vjust = 0,
           textRot = 0,
           segWidth = 0.3,
           lwd = 3)


#manual set of markers
annotation_Markers <-  data.frame(cluster = c("ImmuneCells",
                                            rep("B_cells", 3),
                                            rep("T_cells",3),
                                            rep("NK", 2),
                                            rep("Myeloid",3),
                                            rep("pDC",3)),
                                genes = c("PTPRC", "CD79A", "BANK1", "MS4A1", "CD3E", "CD4", "IL7R", "NKG7", 
                                          "KLRD1","CD68", "CD14","ITGAM", "LILRA4", "CLEC4C", "LRRC26"))

DO.Dotplot(Seu_object = Seu_obj,
           Feature = annotation_Markers,
           group.by.x = "seurat_clusters",
           plot.margin = c(1,1,1,1),
           annotation_x = T,
           point_stroke = 0.1,
           annotation_x_rev = T,
           textSize = 14,
           hjust = 0.5,
           vjust = 0,
           textRot = 0,
           segWidth = 0.3,
           lwd = 3)

```

The manual markers for the immune cells show an agreement for the annotation therefore we can continue with it after some minor adjustments

```{r renaming}
Seu_obj$annotation <- plyr::revalue(Seu_obj$seurat_clusters, c(`1` = "T_cells",
                                                               `2` = "T_cells",
                                                               `3` = "NK",
                                                               `4` = "B_cells",
                                                               `5` = "Monocytes",
                                                               `6` = "NK",
                                                               `7` = "T_cells",
                                                               `8` = "pDC"))

DO.UMAP(Seu_obj, group.by = "annotation", legend.position = "right")

```

## Cell propotions

After the identification of the celltype populations, we can also evaluate if there are significant changes in these populations in the healthy and diseased condition using a wrapper function around the python tool scanpro.

```{r cell populations}
DO.CellComposition(Seu_obj,
                   assay_normalized = "RNA",
                   cluster_column = "annotation",
                   sample_column = "orig.ident",
                   condition_column = "condition",
                   transform_method = "arcsin",
                   n_reps = 3)
```


## Reclustering of cell populations

Subpopulations can be tricky to find, therefore it is always a good practice to perform a reclustering of a given cell populations, if we are interested in a specific set of cells in a population. Here for example in the T cells. We will identify the subpopulations and then markers defining them.

```{r Recluster}
Seu_obj <- DO.FullRecluster(Seu_obj, over_clustering = "annotation")
DO.UMAP(Seu_obj, group.by = "seurat_Recluster")

T_cells <- DO.Subset(Seu_obj,
                     ident = "annotation_recluster",
                     ident_name = grep("T_cells", unique(Seu_obj$annotation_recluster), value = T))

T_markers <- FindAllMarkers(T_cells, group.by = "annotation_recluster")

T_cells <- DO.CellTypist(T_cells,
                         modelName = "Healthy_COVID19_PBMC.pkl",
                         runCelltypistUpdate=F,
                         over_clustering = "annotation_recluster",
                         SeuV5 = F)

T_cells$annotation <- plyr::revalue(T_cells$annotation_recluster, c(`T_cells_1` = "CD4_T_cells",
                                                                    `T_cells_2` = "CD4_T_cells",
                                                                    `T_cells_3` = "CD4_T_cells",
                                                                    `T_cells_4` = "CD8_T_cells"))

```

Now that we identified the marker genes describing the different T cell populations. We can re-annotate them based on their expression profile and a new prediciton from Celltypist.

```{r re-annotate}
Seu_obj <- DO.TransferLabel(Seu_obj,
                            Subset_obj = T_cells,
                            annotation_column = "annotation",
                            subset_annotation = "annotation")

DO.UMAP(Seu_obj, group.by = "annotation", legend.position = "right")
```

##Gene ontology analysis

To explore which biological processes are enriched in a specific cell type across conditions, we can perform gene ontology analysis. We'll start by identifying differentially expressed genes, focusing here on T cells. The `r  DO.enrichR` function uses the enrichR API to run gene set enrichment. It separates the DE genes into up- and down-regulated sets and runs the analysis for each group independently.


```{r GO analysis}
CD4T_cells <- DO.Subset(Seu_obj, ident = "annotation", ident_name = "CD4_T_cells")
DGE_result <- FindMarkers(CD4T_cells,
                          ident.1 = "disease",
                          ident.2 = "healthy",
                          group.by = "condition",
                          min.pct=0,
                          logfc.threshold=0)

DGE_result <- tibble::rownames_to_column(DGE_result, var = "gene")


result_GO <- DO.enrichR(df_DGE = DGE_result,
                        gene_column = "gene",
                        pval_column = "p_val_adj",
                        log2fc_column = "avg_log2FC",
                        pval_cutoff = 0.05,
                        log2fc_cutoff = 0.25,
                        path = NULL,
                        filename = "",
                        species = "Human",
                        go_catgs = "GO_Biological_Process_2023")

result_GO

```

The top significant results can then be visualized in a bar plot.

```{r GO visualisation}
result_GO_sig <- result_GO[result_GO$Adjusted.P.value < 0.05, ] 
result_GO_sig$celltype <- "CD4T_cells"

DO.SplitBarGSEA(df_GSEA = result_GO_sig,
                term_col = "Term",
                col_split = "Combined.Score",
                cond_col = "State",
                pos_cond = "enriched",
                showP = T)

saveRDS(Seu_obj, "~/Downloads/Data10x/Seu_obj_blood10x.rds")
```


# Session information

```{r session_info, echo=FALSE}
options(width = 120)
sessioninfo::session_info()
```

# Bibliography

```{r vignetteBiblio, results = "asis", echo = FALSE, warning = FALSE, message = FALSE}
## Print bibliography
PrintBibliography(bib, .opts = list(hyperlink = "to.doc", style = "html"))
```
